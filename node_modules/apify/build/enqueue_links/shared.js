"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constructPseudoUrlInstances = constructPseudoUrlInstances;
exports.createRequests = createRequests;
exports.createRequestOptions = createRequestOptions;
exports.addRequestsToQueueInBatches = addRequestsToQueueInBatches;

var _url = require("url");

var _underscore = _interopRequireDefault(require("underscore"));

var _utils = require("apify-client/build/utils");

var _pseudo_url = _interopRequireDefault(require("../pseudo_url"));

var _request = _interopRequireDefault(require("../request"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MAX_ENQUEUE_LINKS_CACHE_SIZE = 1000;
/**
 * To enable direct use of the Actor UI `pseudoUrls` output while keeping high performance,
 * all the pseudoUrls from the output are only constructed once and kept in a cache
 * by the `enqueueLinks()` function.
 * @ignore
 */

const enqueueLinksPseudoUrlCache = new Map();
/**
 * Helper factory used in the `enqueueLinks()` and enqueueLinksByClickingElements() function.
 * @param {string[]|Object[]} pseudoUrls
 * @return {PseudoUrl[]}
 * @ignore
 */

function constructPseudoUrlInstances(pseudoUrls) {
  return pseudoUrls.map((item, idx) => {
    // Get pseudoUrl instance from cache.
    let pUrl = enqueueLinksPseudoUrlCache.get(item);
    if (pUrl) return pUrl; // Nothing in cache, make a new instance.

    (0, _utils.checkParamOrThrow)(item, `pseudoUrls[${idx}]`, 'RegExp|Object|String'); // If it's already a PseudoURL, just save it.

    if (item instanceof _pseudo_url.default) pUrl = item; // If it's a string or RegExp, construct a PURL from it directly.
    else if (typeof item === 'string' || item instanceof RegExp) pUrl = new _pseudo_url.default(item); // If it's an object, look for a purl property and use it and the rest to construct a PURL with a Request template.
      else pUrl = new _pseudo_url.default(item.purl, _underscore.default.omit(item, 'purl')); // Manage cache

    enqueueLinksPseudoUrlCache.set(item, pUrl);

    if (enqueueLinksPseudoUrlCache.size > MAX_ENQUEUE_LINKS_CACHE_SIZE) {
      const key = enqueueLinksPseudoUrlCache.keys().next().value;
      enqueueLinksPseudoUrlCache.delete(key);
    }

    return pUrl;
  });
}
/**
 * @param {string[]|Object[]} requestOptions
 * @param {PseudoUrl[]} pseudoUrls
 * @return {Request[]}
 * @ignore
 */


function createRequests(requestOptions, pseudoUrls) {
  if (!(pseudoUrls && pseudoUrls.length)) {
    return requestOptions.map(opts => new _request.default(opts));
  }

  const requests = [];
  requestOptions.forEach(opts => {
    pseudoUrls.filter(purl => purl.matches(opts.url)).forEach(purl => {
      const request = purl.createRequest(opts);
      requests.push(request);
    });
  });
  return requests;
}
/**
 * @param {string[]|Object[]} sources
 * @param {Object} [userData]
 * @ignore
 */


function createRequestOptions(sources, userData = {}) {
  return sources.map(src => typeof src === 'string' ? {
    url: src
  } : src).filter(({
    url
  }) => {
    try {
      return new _url.URL(url).href;
    } catch (err) {
      return false;
    }
  }).map(rqOpts => {
    rqOpts.userData = { ...rqOpts.userData,
      ...userData
    };
    return rqOpts;
  });
}
/**
 * @param {Request[]} requests
 * @param {RequestQueue} requestQueue
 * @param {number} batchSize
 * @return {Promise<QueueOperationInfo[]>}
 * @ignore
 */


async function addRequestsToQueueInBatches(requests, requestQueue, batchSize = 5) {
  const queueOperationInfos = [];

  for (const request of requests) {
    queueOperationInfos.push(requestQueue.addRequest(request));
    if (queueOperationInfos.length % batchSize === 0) await Promise.all(queueOperationInfos);
  }

  return Promise.all(queueOperationInfos);
}