"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Session = void 0;

var _utilities = require("apify-shared/utilities");

var _log = _interopRequireDefault(require("apify-shared/log"));

var _utils = require("apify-client/build/utils");

var _toughCookie = _interopRequireDefault(require("tough-cookie"));

var _events = _interopRequireDefault(require("./events"));

var _constants = require("../constants");

var _session_utils = require("./session_utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  Cookie
} = _toughCookie.default;
/**
 *  Sessions are used to store information such as cookies and can be used for generating fingerprints and proxy sessions.
 *  You can imagine each session as a specific user, with its own cookies, IP (via proxy) and potentially a unique browser fingerprint.
 *  Session internal state can be enriched with custom user data for example some authorization tokens and specific headers in general.
 */

class Session {
  /**
   * Session configuration.
   * @param [options.id] {String} - Id of session used for generating fingerprints. It is used as proxy session name.
   * @param [options.maxAgeSecs=3000] {Number} - Number of seconds after which the session is considered as expired.
   * @param options.userData {Object} - Object where custom user data can be stored. For example custom headers.
   * @param [options.maxErrorScore=3] {number} - Maximum number of marking session as blocked usage.
   * If the `errorScore` reaches the `maxErrorScore` session is marked as block and it is thrown away.
   * It starts at 0. Calling the `markBad` function increases the `errorScore` by 1.
   * Calling the `markGood` will decrease the `errorScore` by `errorScoreDecrement`
   * @param [options.errorScoreDecrement=0.5] {number} - It is used for healing the session.
   * For example: if your session is marked bad two times, but it is successful on the third attempt it's errorScore is decremented by this number.
   * @param options.createdAt {Date} - Date of creation.
   * @param options.expiredAt {Date} - Date of expiration.
   * @param [options.usageCount=0] {Number} - Indicates how many times the session has been used.
   * @param [options.errorCount=0] {Number} - Indicates how many times the session is marked bad.
   * @param [options.maxUsageCount=50] {Number} - Session should be used only a limited amount of times.
   * This number indicates how many times the session is going to be used, before it is thrown away.
   * @param options.sessionPool {EventEmitter} - SessionPool instance. Session will emit the `sessionRetired` event on this instance.
   */
  constructor(options = {}) {
    const {
      id = `session_${(0, _utilities.cryptoRandomObjectId)(10)}`,
      cookies = [],
      // @TODO: Delete, deprecate or leave it as custom cookie persistance?
      cookieJar = new _toughCookie.default.CookieJar(),
      maxAgeSecs = 3000,
      userData = {},
      maxErrorScore = 3,
      errorScoreDecrement = 0.5,
      createdAt = new Date(),
      usageCount = 0,
      errorScore = 0,
      maxUsageCount = 50,
      sessionPool
    } = options;
    const {
      expiresAt = new Date(Date.now() + maxAgeSecs * 1000)
    } = options; // Validation

    (0, _utils.checkParamOrThrow)(id, 'options.id', 'String');
    (0, _utils.checkParamOrThrow)(maxAgeSecs, 'options.maxAgeSecs', 'Number');
    (0, _utils.checkParamOrThrow)(userData, 'options.userData', 'Object');
    (0, _utils.checkParamOrThrow)(maxErrorScore, 'options.maxErrorScore', 'Number');
    (0, _utils.checkParamOrThrow)(expiresAt, 'options.expiresAt', 'Maybe Date');
    (0, _utils.checkParamOrThrow)(createdAt, 'options.createdAt', 'Date');
    (0, _utils.checkParamOrThrow)(usageCount, 'options.usageCount', 'Number');
    (0, _utils.checkParamOrThrow)(errorScore, 'options.errorScore', 'Number');
    (0, _utils.checkParamOrThrow)(maxUsageCount, 'options.maxUsageCount', 'Number');
    (0, _utils.checkParamOrThrow)(sessionPool, 'options.sessionPool', 'Object'); // sessionPool must be instance of SessionPool.

    if (sessionPool.constructor.name !== 'SessionPool') {
      throw new Error('Session: sessionPool must be instance of SessionPool');
    } // Configurable


    this.id = id;
    this.cookies = cookies;
    this.cookieJar = cookieJar.setCookie ? cookieJar : _toughCookie.default.CookieJar.fromJSON(JSON.stringify(cookieJar));
    this.maxAgeSecs = maxAgeSecs;
    this.userData = userData;
    this.maxErrorScore = maxErrorScore;
    this.errorScoreDecrement = errorScoreDecrement; // Internal

    this.expiresAt = expiresAt;
    this.createdAt = createdAt;
    this.usageCount = usageCount; // indicates how many times the session has been used

    this.errorScore = errorScore; // indicates number of markBaded request with the session

    this.maxUsageCount = maxUsageCount;
    this.sessionPool = sessionPool;
  }
  /**
   * indicates whether the session is blocked.
   * Session is blocked once it reaches the `maxErrorScore`.
   * @return {boolean}
   */


  isBlocked() {
    return this.errorScore >= this.maxErrorScore;
  }
  /**
   * Indicates whether the session is expired.
   * Session expiration is determined by the `maxAgeSecs`.
   * Once the session is older than `createdAt + maxAgeSecs` the session is considered expired.
   * @return {boolean}
   */


  isExpired() {
    return this.expiresAt <= new Date();
  }
  /**
   * Indicates whether the session is used maximum number of times.
   * Session maximum usage count can be changed by `maxUsageCount` parameter.
   * @return {boolean}
   */


  isMaxUsageCountReached() {
    return this.usageCount >= this.maxUsageCount;
  }
  /**
   * Indicates whether the session can be used for next requests.
   * Session is usable when it is not expired, not blocked and the maximum usage count has not be reached.
   * @return {boolean}
   */


  isUsable() {
    return !this.isBlocked() && !this.isExpired() && !this.isMaxUsageCountReached();
  }
  /**
   * This method should be called after a successful session usage.
   * It increases `usageCount` and potentially lowers the `errorScore` by the `errorScoreDecrement`.
   */


  markGood() {
    this.usageCount += 1;

    if (this.errorScore > 0) {
      this.errorScore -= this.errorScoreDecrement;
    }
  }
  /**
   * Gets session state for persistence in KeyValueStore.
   * @return {Object} represents session internal state.
   */


  getState() {
    return {
      id: this.id,
      cookies: this.cookies,
      cookieJar: this.cookieJar.toJSON(),
      userData: this.userData,
      maxErrorScore: this.maxErrorScore,
      errorScoreDecrement: this.errorScoreDecrement,
      expiresAt: this.expiresAt.toISOString(),
      createdAt: this.createdAt.toISOString(),
      usageCount: this.usageCount,
      errorScore: this.errorScore
    };
  }
  /**
   * Marks session as blocked and emits event on the `SessionPool`
   * This method should be used if the session usage was unsuccessful
   * and you are sure that it is because of the session configuration and not any external matters.
   * For example when server returns 403 status code.
   * If the session does not work due to some external factors as server error such as 5XX you probably want to use `markBad` method.
   */


  retire() {
    // mark it as an invalid by increasing the error score count.
    this.errorScore += this.maxErrorScore;
    this.usageCount += 1; // emit event so we can retire browser in puppeteer pool

    this.sessionPool.emit(_events.default.SESSION_RETIRED, this);
  }
  /**
   * Increases usage and error count.
   * Should be used when the session has been used unsuccessfully. For example because of timeouts.
   */


  markBad() {
    this.errorScore += 1;
    this.usageCount += 1;
  }
  /**
   * Retires session based on status code.
   * @param statusCode {Number} - HTTP status code
   * @param blockedStatusCodes {Array<Number>} - Custom HTTP status codes that means blocking on particular website.
   * @return {boolean} whether the session was retired.
   */


  retireOnBlockedStatusCodes(statusCode, blockedStatusCodes = []) {
    const isBlocked = _constants.STATUS_CODES_BLOCKED.concat(blockedStatusCodes).includes(statusCode);

    if (isBlocked) {
      this.retire();
    }

    return isBlocked;
  }
  /**
   * Sets cookies from response to the cookieJar.
   * Parses cookies from `set-cookie` header and sets them to `Session.cookieJar`.
   * @param response
   */


  setCookiesFromResponse(response) {
    try {
      const cookies = (0, _session_utils.getCookiesFromResponse)(response).filter(c => c);

      this._setCookies(cookies, response.url);
    } catch (e) {
      // if invalid Cookie header is provided just log the exception.
      _log.default.exception(e, 'Session: Could not get cookies from response');
    }
  }
  /**
   * Set cookies to session cookieJar.
   * Cookies array should be [puppeteer](https://pptr.dev/#?product=Puppeteer&version=v2.0.0&show=api-pagecookiesurls) cookie compatible.
   * @param cookies {Array<Object>}
   * @param url {String}
   */


  setPuppeteerCookies(cookies, url) {
    try {
      this._setCookies(cookies.map(this._puppeteerCookieToTough), url);
    } catch (e) {
      // if invalid cookies are provided just log the exception. No need to retry the request automatically.
      _log.default.exception(e, 'Session: Could not set cookies in puppeteer format.');
    }
  }
  /**
   * Gets cookies in puppeteer ready to be used with `page.setCookie`.
   * @param url {String} - website url. Only cookies stored for this url will be returned
   * @return {Array<Object>}
   */


  getPuppeteerCookies(url) {
    const cookies = this.cookieJar.getCookiesSync(url);
    return cookies.map(this._toughCookieToPuppeteer);
  }
  /**
   * Wrapper around `tough-cookie` Cookie jar `getCookieString` method.
   * @param url
   * @return {String} - represents `Cookie` header.
   */


  getCookieString(url) {
    return this.cookieJar.getCookieStringSync(url, {});
  }
  /**
   *  Transforms puppeteer cookie to tough-cookie.
   * @param puppeteerCookie {Object} - Cookie from puppeteer `page.cookies method.
   * @return {Cookie}
   * @private
   */


  _puppeteerCookieToTough(puppeteerCookie) {
    return new Cookie({
      key: puppeteerCookie.name,
      value: puppeteerCookie.value,
      expires: new Date(puppeteerCookie.expires),
      domain: puppeteerCookie.domain,
      path: puppeteerCookie.path,
      secure: puppeteerCookie.secure,
      httpOnly: puppeteerCookie.httpOnly
    });
  }
  /**
   *  Transforms tough-cookie cookie to puppeteer Cookie .
   * @param toughCookie - Cookie from CookieJar.
   * @return {Object} - puppeteer cookie
   * @private
   */


  _toughCookieToPuppeteer(toughCookie) {
    return {
      name: toughCookie.key,
      value: toughCookie.value,
      expires: new Date(toughCookie.expires).getTime(),
      domain: toughCookie.domain,
      path: toughCookie.path,
      secure: toughCookie.secure,
      httpOnly: toughCookie.httpOnly
    };
  }
  /**
   * Sets cookies.
   * @param cookies
   * @param url
   * @private
   */


  _setCookies(cookies, url) {
    for (const cookie of cookies) {
      this.cookieJar.setCookieSync(cookie, url, {
        ignoreError: false
      });
    }
  }

}

exports.Session = Session;